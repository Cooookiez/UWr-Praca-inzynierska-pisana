%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%------------------------------------------------------------
%
\documentclass[a4paper,12pt,reqno]{article}
%----------------------------------------------------------
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{color}
\usepackage{amssymb,amsmath}
\usepackage{polski}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{caption}
\geometry{margin=1.1in}
\usepackage{wrapfig}
\usepackage{lipsum}  
\usepackage{listings}
\usepackage[toc,page]{appendix}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{subcaption}
\usepackage{minted}
\usepackage{mdframed}
\usepackage{tabularx}
\usepackage{float}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage[bottom]{footmisc}

\definecolor{codegreen}{rgb}{0.5, 0.09, 0.09}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.94,0.94,0.94}
\definecolor{gray}{rgb}{0,0.6,0}
\definecolor{codebg}{RGB}{186, 186, 186}

% color codes
\definecolor{new}{RGB}{14, 107, 0}
\definecolor{edited}{RGB}{181, 154, 0}
\definecolor{to_change}{RGB}{255, 0, 0}
\definecolor{to_check_at_end}{RGB}{172, 0, 181}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},  
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
	basicstyle=\footnotesize\fontfamily{cmtt}\selectfont,
    breakatwhitespace=false,         
    breaklines=true,
    captionpos=b,
	language=C++,
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}
\lstset{literate=%
    *{0}{{{\color{gray}0}}}1
    {1}{{{\color{gray}1}}}1
    {2}{{{\color{gray}2}}}1
    {3}{{{\color{gray}3}}}1
    {4}{{{\color{gray}4}}}1
    {5}{{{\color{gray}5}}}1
    {6}{{{\color{gray}6}}}1
    {7}{{{\color{gray}7}}}1
    {8}{{{\color{gray}8}}}1
    {9}{{{\color{gray}9}}}1
}
%------------------------------------------------------------
\begin{document}

%\begin{figure}[h]
%	\centering
%		\includegraphics[width=0.40\textwidth]{logo.pdf}
%\end{figure}


\begin{center}

\thispagestyle{empty}

%UNIWERSYTET WROCŁAWSKI\\
\Large 
Uniwersytet Wrocławski\\
Wydział Fizyki i Astronomii\\
\vspace{0.8cm}
\vspace{1.8cm}

\Large Krzysztof Kukiz \\
\vspace{3.2cm}
\Large \textbf{Inteligentne powitanie na podstawie rozpoznawania twarzy} \\
\vspace{1.5cm}
Smart greeting based on face recognition
\end{center}
\vspace{3.7cm}
\begin{flushright}
\large{Praca inżynierska na kierunku \\Informatyka Stosowana i Systemy Pomiarowe \\}
\vspace{0.5cm}
\large{ Opiekun \\ dr hab. Maciej Matyka, prof. UWr}
\end{flushright}
\vspace{2.2cm}

\begin{center}
\large Wrocław, \today
\end{center}

\newpage

\tableofcontents

\newpage

%
%	Streszczenie PL
%
\begin{flushleft}
\Large \textbf{Streszczenie}
\end{flushleft}
\vspace{1cm}

Niniejsza praca przedstawia projekt systemu inteligentnego rozpoznawania osób oraz podejmowania przez system wcześniej zdefiniowanych działań, w zależności od rozpoznanej osoby. W przypadku braku rozpoznania osoby, system poda także odpowiedni komunikat głosowy oraz wizualny. 

Projekt oparty jest na Raspberry Pi 4B, na języku programowania python 3, oraz wykorzystuje elementy wydrukowane na drukarce 3D Creality Ender-3 v.2.

Projekt łączy ze sobą w całość 3 warstwy niezbędne do wykonania wszystkich założonych zadań w taki sposób aby w przyszłości można było rozbudować system o kolejne funkcjonalności: warstwę sprzętową (kamery, mikro-komputera Raspberry Pi, głośnika, wyświetlacza), warstwę programistyczną odpowiedzialną za obróbkę oraz optymalizację odczytanego obrazu, interpretację pobranego obrazu oraz porównanie go z wcześniej zdefiniowaną bazą zdjęć, podjęcie decyzji o tym jakie działanie ma być podjęte oraz wygenerowanie właściwego sygnału skutkującego podjęciem określonych, warstwę produktową w postaci dedykowanej, zaprojektowanej specjalnie dla tego projektu obudowy będącej jednocześnie opakowaniem produktu, pełniącej jego funkcje organizacyjną, ochronną, informacyjną.

Głównym celem projektu było stworzenie systemu mobilnego, o jak najmniejszych wymiarach, który jest gotowy do działania natychmiast po podłączeniu zasilania.

%
%	Streszczenie EN
%
\newpage
\begin{flushleft}
\Large \textbf{Abstract}
\end{flushleft}
\vspace{1cm}

This work presents the design of a system for the intelligent recognition of persons and for the system to take predefined actions, depending on the recognised person. If the person is not recognised, the system will also give an appropriate voice and visual message.

The project is based on a Raspberry Pi 4B, the python 3 programming language, and uses components printed on a Creality Ender-3 v.2 3D printer.

The project brings together the 3 layers needed to carry out all the tasks in such a way that the system can be extended in the future with further functionalities: A hardware layer (the camera, the Rasppery Pi micro-computer, a speaker, a display), the programming layer responsible for processing and optimisation of the read image, interpretation of the retrieved image and comparison with a predefined image database, deciding on the action to be taken and generating the right signal to take the specified action, a product layer in the form of a dedicated enclosure (Etui), designed specifically for this project, performing its organisational, protective, informative functions.

The main goal of the project was to create a mobile system, with the smallest possible dimensions, which is ready to operate immediately after connecting the power supply.

\newpage

%
%	Wstęp
%
\section{Wstęp} \label{section:wstep}

\subsection{Wprowadzenie}

Systemy inteligentne są stosowane obecnie na całym świecie. Znajdują coraz szersze zastosowanie w życiu codziennym każdego z nas zarówno w pracy jak i w domu. Potrafią reagować na nasze zachowania, odczytywać intencje oraz gromadzić i wykorzystywać dane, które im udostępnimy zarówno na poziomie jednostki, jak i całych grup społecznych.

W naszym codziennym życiu są elementem składowym inteligentnych budynków opartych między innymi o systemy LOXONE, KNX, AMPIO, czy też FIBARO\footnote{LOXONE, KNX, AMPIO, FIBARO są to nazwy producentów oferujących rozwiązania stosowane w budowie domów inteligentnych} i znacznie ułatwiają codzienne czynności poprzez sterowanie klimatem, ogrzewaniem, rekuperacją, czy też podlewaniem ogrodów, sprzątaniem, a nawet optymalnym wykorzystaniem energii elektrycznej.

Systemy inteligentne pomimo swoich kosztów zdobywają coraz większą popularność nie tylko w zastosowaniach profesjonalnych, ale także w zastosowaniach prywatnych i mogą być oparte zarówno o infrastrukturę przewodową (patrz rys. \ref{kable}), jak i mogą być oparte na rozwiązaniach bezprzewodowych.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/domkable.jpg}
\caption{Przykład okablowania domu inteligentnego \cite{img_me}. \label{kable}}
\quad
\end{figure}

Żaden system nie posiada jednak wszystkich funkcjonalności, które są niezbędne danemu użytkownikowi. W większości z nich brakuje mobilnego systemu pozwalającego na rozpoznanie osób oraz podjęcia konkretnych działań w zależności od osoby, która została zidentyfikowana.

System inteligentnego rozpoznawania osób, który jest tematem niniejszego projektu, docelowo ma umożliwić identyfikację osób wchodzących do pomieszczenia na podstawie zapisanej wcześniej bazy zdjęć oraz powitanie ich indywidualnym komunikatem zarówno głosowym, jak i wizualnym.

Do realizacji projektu wykorzystałem mikro-komputer Raspperry Pi 4B oraz język programowania Python 3. Jako elementu wejściowego sygnału użyłem kamery Raspberry Pi Camera HD v2 8MPx zgodnej z Raspperry Pi 4B, oraz głośnika pod wejscie jack 3,5mm.

\subsection{Cel i zakres pracy}

Celem głównym projektu jest stworzenie prototypu inteligentnego, mobilnego systemu rozpoznawania osób, na podstawie wcześniej zgromadzonej bazy zdjęciowej, a także wygenerowanie unikatowego powitania głosowego oraz wizualnego w zależności od rozpoznanej osoby.

Celami szczegółowymi projektu są: wybór technologii sprzętowej, wybór technologii programistycznej oraz zaprojektowanie i wykonanie obudowy prototypu, mieszczącej wszystkie elementy projektu.

Praca swoim zakresem obejmuje zarówno tematykę z dziedziny elektroniki, informatyki projektowania oraz prototypowania 3D.

W zakresie elektroniki wykorzystane zostały układy i sensory zgodne z płytką Rasppery 4B, w zakresie informatyki napisany został program w języku Python 3 i wykorzystujący do realizacji zadań dostępne biblioteki, natomiast w zakresie prototypowania z wykorzystaniem druku 3D, użyta została drukarka 3D Creality Ender v2 oraz materiał EASY PET-G. Do celów zaprojektowania obudowy wykorzystano program SOLIDWORKS.

Projekt z jednej strony pokazuje, że połączenie wiedzy z zakresu elektroniki, informatyki oraz projektowania dostarcza każdemu studentowi odpowiednią wiedzę oraz umiejętności, do wykonania prototypu od fazy projektowej do fazy praktycznego zastosowania,  z drugiej udowadnia, że wiedza ta pozwala na wykonania projektu z wykorzystaniem elementów ogólnodostępnych na rynku.

\subsection{Struktura pracy} % tutorial jak prrace czytać

Rozdział pierwszy zawiera wstęp, wprowadzenie, opis celu oraz zakresu pracy, a także strukturę pracy. Znajdują się w nim podstawowe informacje opisujące główne elementy składowe projektu, oraz umożliwia szybkie zapoznania się z projektem na poziomie ogólnym.

Rozdział drugi zawiera założenia odnośnie szczegółowych wymagań stawianych projektowi i umożliwia zrozumienie koncepcji projektu zarówno na poziomie ogólnym i bardziej szczegółowym.

Rozdział trzeci zawiera zestawienie założone funkcjonalności projektu, które będą zaimplementowane w projektowanym systemie oraz sposób korzystania z tych funkcjonalności.

Rozdział czwarty zawiera szczegółowy opis warstwy sprzętowej z wyszczególnieniem użytych w projekcie podzespołów oraz ich parametrów. Znajdują się w nim szczegółowe opisy użytej do projektu kamery, mikro-komputera Raspberry Pi, głośnika oraz ekranu służącego do komunikacji z użytkownikiem.

W rozdziale piątym znajduje się opis warstwy programistycznej projektu z uzasadnieniem wyboru języka Python jako języka programowania użytego w projekcie, opis zastosowanych bibliotek, algorytm oraz główne elementy kodu odpowiedzialne za działanie całego projektu.

W rozdziale szóstym znajduje się opis warstwy produktowej projektu z opisem użytej technologii druku 3D, kroków projektowania obudowy, procesu wykonania obudowy oraz szczegółów samej obudowy.

W rozdziale siódmym opisane zostały kwestie związane z samą realizacją projektu, napotkane problemy oraz sposoby jakimi problemy zostały rozwiązane. Omówiono także potencjalne możliwości rozbudowy projektu o kolejne funkcjonalności i zastosowania.

W rozdziale ósmym zawarto wnioski oraz „Lessons learned” z wykonanego projektu. Stanowią one podstawę do dalszego doskonalenia podejścia przy kolejnych projektach.

\newpage
\section{Wymagania stawiane projektowi} \label{section:wymagania}

W celu realizacji pracy w pierwszej kolejności określone zostały wymagania, które stanowiły punkt docelowy projektu, jaki należało osiągnąć w ramach prac projektowych, a następnie pozwoliły na zaplanowanie drogi dojścia do założonego celu.

Na podstawie założonego celu zostały określone kroki milowe, które należało osiągnąć. Kroki te dzieliły cały projekt na mniejsze etapy, z jednej strony pozwalające na lepszy nadzór nad postępami pracy, oraz natychmiastowe określenie punktów stanowiących problem i wstrzymujących postępy, a z drugiej strony pozwalały na elastyczne reagowanie i zmiany projektowe bez konieczności zmian poprzednich etapów.

Takie podejście miało zapewnić iż ewentualny błąd popełniony na dalszych etapach nie będzie miał wpływu na etapy poprzednie projektu.

\begin{figure}[H]%
\centering
\includegraphics[width=0.5\columnwidth]{imgs/etapy.drawio.jpg}
\caption{Etapy prac projektowych \cite{img_me}. \label{etapypracy}}
\quad
\end{figure}

\subsection{Wymagania dla prototypu}

W ramach realizacji projektu określone zostały następujące wymagania dla prototypu.

\begin{itemize}
	\item \textbf{Mobilność.} Głównym założeniem projektu jest mobilność prototypu. Oznacza to, iż będzie posiadał wymiary oraz wagę umożliwiającą łatwe przenoszenie w dowolne miejsce,
	\item \textbf{Łatwość zasilania.} Prototyp powinien mieć możliwość zasilania z ogólnodostępnej sieci 230V, tak aby istniała możliwość stałego podłączenia do gniazda elektrycznego. Opcjonalnie założono, że prototyp będzie posiadał możliwość podłączenia do zasilania z powerbanku, tak aby mógł znaleźć zastosowanie w miejscach, w których dostęp do sieci elektrycznej jest utrudniony,
	\item \textbf{Dostępność.} Prototyp zostanie wykonany ze standardowych elementów dostępnych na rynku polskim,
	\item \textbf{Relatywnie niski koszt.} Wykonanie prototypu powinno mieścić się w kwocie nie większej niż 1000 zł,
	\item \textbf{Łatwość obsługi.} Prototyp będzie umożliwiał obsługę bez konieczności znajomości zagadnień technicznych. Zadaniem użytkownika będzie jedynie wprowadzenie bazy zdjęć do określonego folderu, oraz uruchomienie dwóch programów:
		\begin{itemize}
			\item program "zapisujący" zdjęcia twarzy do zakodowanego pliku;
			\item główny program rozpoznający osoby przechodzące przed kamerą;
		\end{itemize}
	i odpowiednie nakierowanie kamery prototypu,
	\item \textbf{Łatwość rozbudowy.} Platforma na jakiej zostanie zbudowany prototyp będzie pozwalała na jego łatwą rozbudowę,
	\item \textbf{Łatwość programowania.} System będzie oparty o jeden z popularnych języków programowania, w którym dostępne są biblioteki niezbędne do realizacji wszystkich zadań, tak aby użytkownik mógł skorzystać z dostępnych standardowych rozwiązań programistycznych, bez ponoszenia dodatkowych kosztów.
\end{itemize}

\subsection{Wymagania dla procesu projektowego}

W celu wykonania prototypu zostały określone następujące wymagania dla procesu projektowego.

\begin{itemize}
	\item \textbf{Elastyczność.} Projekt zostanie podzielony na mniejsze etapy, tak aby w każdej chwili istniała możliwość modyfikacji założeń lub działań przy jednoczesnym zapewnieniu realizacji założonych celów,
	\item \textbf{Dostępność narzędzi.} Dla każdego etapu projektu zostaną użyte narzędzia dostępne na rynku, tak aby uniknąć konieczności projektowania samych narzędzi,
	\item \textbf{Przejrzystość.} Na każdym etapie status prac będzie łatwo weryfikowalny aby zidentyfikować potencjalne przeszkody mogące powodować opóźnienie realizacji projektu,
	\item \textbf{Backup.} W celu uniknięcia utraty danych lub kodu źródłowego zostanie wykorzystane repozytorium Git. Wersja dostępna online znajduje się na Githubie \cite{moj_github}.
\end{itemize}

\newpage
\section{Oczekiwane funkcjonalności projektu} \label{section:oczekiwania}

W ramach realizacji projektu zostały zaimplementowane następujące funkcjonalności.

\begin{itemize}
	\item \textbf{Zapis zdjęć twarzy} do postaci numerycznej. Użytkownik do imiennych folderów wprowadza zdjęcia twarzy osoby (np. zdjęcia Jana wrzucam do folderu "Jan Nowak") i uruchamia program kodujący zamieniając zdjęcie twarzy na wartości liczbowe,
	\item \textbf{Użycie syntezatora mowy.} System korzysta z syntezatora mowy w celu dodania domyślnego powitania do pliku .mp3,
	\item \textbf{Wykrycie osoby.} System skanuje wybrany obszar przestrzeni i wykrywa czy w nadzorowanym obszarze znajduje się osoba. W przypadku wykrycia aktywowane są kolejne kroki programu. System pomija zwierzęta oraz przedmioty,
	\item \textbf{Skanowanie  twarzy.} Po wykryciu obiektu kamera koncentruje się na twarzy wykrytej osoby i koduje twarz w celu porównania z lokalną bazą,
	\item \textbf{Porównanie (Identyfikacja) twarzy.} System porównuje zakodowane zdjęcia z wcześniej zakodowanymi zdjęciami znajdującymi się w bazie danych. System przekształca dane wejściowe do macierzy liczb. Funkcja z biblioteki porównuje wszystkie macierze i patrzy czy dana osoba istnieje,
	\item \textbf{Komunikat głosowy.} Z puli powitań plików .mp3 (domyślnie jeden, można wrzucić własne dzwięki), program losuje jeden i go odpala (w przypadku gdy jest tylko jeden plik, losowanie się nie odbywa),
	\item \textbf{Komunikat wizualny.} Na ekranie dodatkowo pojawia się komunikat graficzny z imieniem i nazwiskiem (Patrz rys. \ref{komunikatgraficzny:komunikatgraficzny}\subref{komunikatgraficzny:rozpoznana}). W przypadku wykrycia osoby nieznanej pojawia się stosowny komunikat (Patrz rys. \ref{komunikatgraficzny:komunikatgraficzny}\subref{komunikatgraficzny:NIErozpoznana}).
\end{itemize}
\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{imgs/rozpoznanoTAK.jpg}
		\caption{Rozpoznanej osoby \cite{img_me}.}	
		\label{komunikatgraficzny:rozpoznana}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{imgs/rozpoznanoNIE.jpg}
		\caption{NIE rozpoznanej osoby \cite{img_me}.}
		\label{komunikatgraficzny:NIErozpoznana}
	\end{subfigure}%
\caption{Komunikaty graficzne}
\label{komunikatgraficzny:komunikatgraficzny}
\end{figure}

Powyższe funkcjonalności pozwalają na realizację funkcji

\begin{itemize}
	\item powitania,
	\item nadzór obszaru.
\end{itemize}

Przykłady realizacji funkcji powitania:
\begin{itemize}
	\item "urządzenie rozpoznało Jana, który ma 3 wersje powitania. Program wylosuje i powie jedno z:"
	\begin{itemize}
		\item "Cześć Jan, miło Cię widzieć",
		\item "Witaj w domu Janek",
		\item "Panie Janie, Panie Janie ..." % ♫ ... ♫
	\end{itemize}
	\item "urządzenie rozpoznało Adama Nowaka, który ma tylko podstawowe pytanie. Program bez losowania odrazu je wybierze i powie:"
	\begin{itemize}
		\item "Witaj Adam Nowak"
	\end{itemize}
	\item dla nierozpoznanej osoby możemy mieć tylko domyślne przywitanie, ale możemy dać ich więcej. Program zachowa się analogicznie do wcześniej wymienionych przypadków:
	\begin{itemize}
		\item "Witaj nieznajomy"
		\item "Witamy w domostwie Nowaków"
	\end{itemize}
\end{itemize}

\newpage
\section{Warstwa sprzętowa} \label{section:warstwa_sprzetowa}

W ramach warstwy sprzętowej projekt składa się z 4 elementów. Kamery, mikro-komputera Raspberry Pi, głośnika oraz ekranu.

Podstawą systemu jest Raspberry Pi, do którego podłączone są wszystkie elementy wejściowe oraz wyjściowe prototypu, tak aby stanowiły spójną całość. W ten sposób przygotowana warstwa sprzętowa będzie następnie oprogramowana (patrz rozdział ~\ref{section:warstwa_programistyczna}) oraz zabezpieczona obudową pełniącą jednocześnie funkcje opakowania (patrz rozdział ~\ref{section:warstwa_produkcyjna}).

\subsection{Kamera jako element wejściowy}

Spośród dostępnych kamer w projekcie zastosowano kamerę  HD v2 8MPx dedykowaną do mikro-komputera Raspberry Pi. Urządzenie posiada matrycę o rozdzielczości 8 Mpx, wspiera tryb HD 1080p, 720p oraz 640 x 480p oraz jest w stanie wykonywać zdjęcia w wyższej rozdzielczości 3280 x 2464 px.

Aby uniknąć potencjalnych problemów w przesyle sygnału zastosowano oficjalny moduł Raspberry Pi Camera HD v2, który jest całkowicie zgodny ze sterownikami, dostarczanymi wraz z systemem Raspberry Pi OS.

Dzięki takiemu rozwiązaniu możliwe jest jednocześnie szerokie wsparcie w zakresie dokumentacji, tutoriali oraz bibliotek programistycznych.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/camera.jpg}
\caption{Kamera HD \cite{img_cam}. \label{kamera}}
\quad
\end{figure}

Parametry kamery

\begin{itemize}
	\item 1080p / 30 fps,
	\item 720p / 60 fps,
	\item 640 x 480p / 90 fps.
\end{itemize}

\subsection{Płyta Raspberry Pi}

Spośród dostępnych modeli Raspberry Pi do projektu wykorzystano model w wersji 4B, który charakteryzuje się zwiększoną pojemnością pamięci RAP (4GB) oraz wydajniejszym procesorem (Broadcom BCM2711) quad-core 64-bitowy ARM-8.

Posiada on dwa złącza microHDMI, dwa złączami USB 3.0 i 2 złącza USB 2.0. Zasilanie realizowane jest przez złącze USB C.

Mikro-komputer wyposażony jest także w dwuzakresowe WiFi 2,4 GHz i 5 GHz, Bluetooth w standardzie 5, oraz port Ethernet o prędkości do 1000 Mb/s.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/raspberrypi4.jpg}
\caption{Raspberry Pi 4B \cite{img_rp4b}. \label{rp4b}}
\quad
\end{figure}

Specyfikacja techniczna

\begin{itemize}
	\item Pamięć RAM - 1GB, 2GB lub 4GB LPDDR4,
	\item Procesor - Broadcom BCM2711, quad-core Cortex-A72 (ARM v8) 64-bit SoC @ 1.5GHz,
	\item 4 × USB,
	\item mini jack 3.5mm,
	\item Karta pamięci - microSD,
	\item Systemy operacyjne - Linux Raspbian, Windows 10 loT i wiele innych,
	\item Temperatura pracy - 0–50°C,
	\item Zasilanie - złącze USB C minimum 5V/3A, złącza GPIO minimum 5V/3A PoE przy zastosowaniu dedykowanej nakładki,
	\item Wymiary - 85 x 56 x 17 mm.
\end{itemize}

\subsection{Głośnik, jako element wyjściowy}

W zakresie komunikatów głosowych w projekcie został zastosowany głośnik LOGIC CONCEPT LS-09.

Logic Concept LS-09, to zestaw dwóch głośników, które można podłączyć zarówno do komputerów stacjonarnych, laptopów, jak i różnego rodzaju urządzeń multimedialnych. Głośniki charakteryzują się niewielkimi rozmiarami, co było jednym z warunków niezbędnych do realizacji projektu.

Każdy głośnik o mocy 3W. Dzięki niewielkim rozmiarom oraz lekkiej konstrukcji w łatwy i wygodny sposób można je przetransportować.

Zasilane realizowane jest poprzez kabel USB podłączany do Raspberry Pi.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/glosnik.jpg}
\caption{Głośniki LOGIC CONCEPT LS-09 \cite{img_me}.  \label{glosnik}}
\quad
\end{figure}

\subsection{Ekran, jako element wyjściowy}

W projekcie został zastosowany ekran Ekran dotykowy Waveshare 9904. Jest to ekran rezystancyjny LCD TFT o przekątnej 3,5'' i rozdzielczości 320x480px kompatybilny z Raspberry Pi 4/3/2/B+/Zero.

Oprogramowanie ekranu dotykowego przygotowane przez producenta zawiera sterowniki.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/ekran.jpg}
\caption{Ekran Waveshare 9904 \cite{img_screen}. \label{ekran}}
\quad
\end{figure}

Specyfikacja ekranu dotykowego Waveshare

\begin{itemize}
	\item Typ: ekran dotykowy, rezystancyjny,
	\item Przekątna: 3.5",
	\item Rozdzielczość: 320px x 480px,
	\item Komunikacja SPI,
	\item Współpracuje z: Raspberry Pi w wersji 4B, 3B+, 3B, 2B, B+, Zero i Zero,
	\item Wymiary ekranu: 85mm x 56.5mm.
\end{itemize}

\subsection{Radiatory}

W celu odprowadzenia ciepła z podzespołów został zastosowany zestaw radiatorów do Raspberry Pi - z taśmą termoprzewodzącą.

Radiatory zbudowane są ze stopów metali dobrze przewodzących ciepło. Ich powierzchnia od strony zewnętrznej jest rozwinięta w postaci żeber.

\newpage
\section{Warstwa programistyczna} \label{section:warstwa_programistyczna}
\subsection{Python, jako język programowania}
% dlaczego python a nie c++
W celu realizacji funkcji prototypu zostały wzięte pod uwagę języki C++ oraz Python. Po wstępnej analizie został wybrany język Python ze względu na wsparcie producenta Raspberry Pi \cite{watki_jak_pisac}, większy wybór bibliotek \cite{face_detection_and_recognition_using_opencv} oraz łatwiejszy do pisania i debugowania kod \cite{face_recognition_with_python}. Jednocześnie język programowania Python charakteryzuje się wolniejszym działaniem w porównaniu do języka c++, co w moim przypadku nie jest problemem, gdyż najbardziej wymagająca biblioteka jest napisana pod pythona właśnie w języku c++. Dzięki czemu nie tracę na szybkości.

Z tego powodu biorąc pod uwagę przede wszystkim:
\begin{itemize}
\item większy wybór bibliotek,
\item wsparcie Raspberry Pi,
\item przejrzystość kodu,
\end{itemize}
to język Python stanowi lepszy wybór.
\subsection{Biblioteki}
% lista bibliotek i do czego je wykorzystuje
W celu realizacji poszczególnych zadań zostały użyte następujące biblioteki języka Python:
\begin{itemize}
\item cv2, odpowiadająca za pobieranie obrazu z kamerki,
\item face\_recognition, odpowiadająca za rozpoznawanie twarzy \cite{face_recognition_github} \cite{face_recognition_implementation_on_raspberrypi} \cite{face_recognition_python},
\item gtts, odpowiadająca za stworzenie deflautowego powitania do pliku .mp3,
\item json, odpowiadająca za zapisywanie i odczytywanie zakodowanych twarzy do plików,
\item numpy, odpowiadająca za tworzenie zoptymalizowanych pod bibliotekę rozpoznawania twarzy macierzy,
\item os, odpowiadająca za poruszanie się po folderach,
\item pygame, odpowiadająca za odtworzenie powitalnego dźwięku,
\item random, odpowiadająca za wybranie losowej ścieżki do otworzenia,
\item sys, odpowiadająca za pobranie wartości przy uruchomieniu programu sprawdzających czy zakodować wszystkich, czy tylko jedną osobę,
\item threading, odpowiadająca za wykorzystywanie przez program wszystkich dostępnych wątków procesora,
\item tkinter - odpowiada za wyświetlenie obrazu.
\end{itemize}

\newpage
\subsection{Algorytm}
% prostokąty, kułka i trujkąty
Poniżej znajdują się algorytmy programów zastosowanych w projekcie:

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{imgs/generujacy.drawio.jpg}
\caption{Program kodujący zdjęcia do plików .json \cite{img_me}. \label{algorytm_encode_faces}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{imgs/glowny.drawio.jpg}
\caption{Algorytm programu głównego \cite{img_me}. \label{algorytm_start_recognition}}
\quad
\end{figure}

\subsection{Kod}
% screeny / ładne ctrl+c, ctrl+v
W tym rozdziale znajdują się listingi kodu odpowiedzialnego za realizację warstwy softwarowej projektu.
Prezentowany kod podzielony jest na następujące elementy:\newline

Zamiana obrazu twarzy na postać cyfrową (kodowanie) (Patrz listing \ref{listing:py_camAndStaff}).
\begin{listing}[H]%
\begin{mdframed}[backgroundcolor=codebg]
\inputminted{python}{code/start_cam.py}
\end{mdframed}
\caption{Optymalizacja klatki wejściowej.}
\label{listing:py_camAndStaff}
\end{listing}

\newpage
Przypisanie rozpoznanej twarzy do zdefiniowanego w bazie danych imienia i nazwiska (Patrz listing \ref{listing:py_encodeThisFrameFaces_1}, \ref{listing:py_encodeThisFrameFaces_2}).
\begin{listing}[H]%
\begin{mdframed}[backgroundcolor=codebg]
\inputminted{python}{code/encodeThisFrameFaces_1.py}
\end{mdframed}
\caption{Rozpoznanie osoby (cz. 1 / 2).}
\label{listing:py_encodeThisFrameFaces_1}
\end{listing}

\begin{listing}[H]%
\begin{mdframed}[backgroundcolor=codebg]
\inputminted{python}{code/encodeThisFrameFaces_2.py}
\end{mdframed}
\caption{Rozpoznanie osoby (cz. 2 / 2).}
\label{listing:py_encodeThisFrameFaces_2}
\end{listing}

\newpage
\begin{listing}[H]%
\begin{mdframed}[backgroundcolor=codebg]
\inputminted{python}{code/create_welcome_voice_for_some_person.py}
\end{mdframed}
\caption{Generowanie domyślnego komunikatu głosowego}
\label{listing:py_make_sound}
\end{listing}

\newpage
\begin{listing}[H]%
\begin{mdframed}[backgroundcolor=codebg]
\inputminted{python}{code/screenVisualization.py}
\end{mdframed}
\caption{Wysłanie komunikatu graficznego na ekran}
\label{listing:py_visual}
\end{listing}

\newpage
Obsługa sytuacji w zależności od tego czy twarz została rozpoznana  (Patrz listing\,\,\ref{listing:py_sytuacje}).
\begin{listing}[H]%
\begin{mdframed}[backgroundcolor=codebg]
\inputminted{python}{code/say_hello_what_action.py}
\end{mdframed}
\caption{Przygotowanie komunikatów głosowych.}
\label{listing:py_sytuacje}
\end{listing}

\newpage
Wysłanie komunikatu głosowego do głośników  (Patrz listing \ref{listing:py_play_sound}).
\begin{listing}[H]%
\begin{mdframed}[backgroundcolor=codebg]
\inputminted{python}{code/say_hello_play_sound.py}
\end{mdframed}
\caption{Odtworzenie pliku mp3.}
\label{listing:py_play_sound}
\end{listing}

\newpage
\section{Warstwa produktowa} \label{section:warstwa_produkcyjna} % wysłać skreeny z solidworksa i zdjęcia obudowy
Prototyp to nie tylko elektronika oraz oprogramowanie. Bardzo ważnym elementem jest stworzenie całościowego produktu, do czego niezbędne jest zaprojektowanie oraz wykonanie odpowiedniej obudowy. W celu realizacji tego zadania zostały użyte poniższe programy:
\begin{itemize}
\item SOLIDWORKS – do tworzenia projektu obudowy (patrz rys. \ref{okno_solidworks},
\item ultimaker cura – do przygodowania wexportowanego z SOLIDWORKS pliku do postaci g-code którą czytają drukatki 3D,
\item octoprint (+ Raspbarry pi) – do nadzorowania wydruku
\end{itemize}
oraz prototypowanie przy pomocy drukarki 3D.
\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/solidworks.jpg}
\caption{Okno programu SOLIDWORKS z projektem obudowy \cite{img_me}. \label{okno_solidworks}}
\quad
\end{figure}
\subsection{Technologia druku 3D}
Druk 3D został wynaleziony z konieczności szybkiego i stosunkowo taniego przygotowywania wszelkiego rodzaju prototypów praktycznie we wszystkich branżach działalności gospodarczej. 
Obecnie prototypowanie przy użyciu wydruków 3D zdecydowanie ułatwia i przyspiesza całość prac od projektu do wykonania wyrobu końcowego.

Zalety prototypowania przy pomocy druku 3D \cite{prototyp3dzalety}:
\begin{itemize}
\item łatwość modyfikacji projektu,
\item możliwość natychmiastowego rozpoczęcia drukowania projektu,
\item brak konieczności oczekiwania na realizację zadania przez firmy zewnętrzne,
\item możliwość zastosowania materiałów o różnych własnościach,
\item relatywnie niska cena.
\end{itemize}

Drukarki 3D używane do prototypowania, wykorzystują 2 podstawowe technologie przyrostowe
\cite{prototyp3dzalety}.
\begin{itemize}
\item SLA, oraz
\item FDM.
\end{itemize}
\textbf{W technologii SLA} do wydruku wykorzystuje się żywicę, która jest materiałem światło utwardzalnym. Poszczególne warstwy nanosi się na specjalnie zaprojektowanej płytce. Poszczególne warstwy utwardzane są wiązką laserową \cite{jakie_materialy_w_druku}.

Zaletą tej metody jest duża dokładność otrzymanego modelu, natomiast podstawową wadą tej technologii jest:
\begin{itemize}
\item stosunkowo wysoki koszt użycia w warunkach domowych, oraz
\item konieczność stosowania wyciągów mechanicznych w celu odprowadzenia powstających w trakcie procesu oparów.
\end{itemize}

\textbf{W technologii FDM} drukarki do druku korzystają z tworzyw plastikowych takich jak ABS oraz PLA \cite{jak_wybrac_tworzywo_do_drukarek} \cite{jakie_materialy_w_druku}.

Do celów realizacji niniejszego projektu wybrałem metodę FDM ze względu na jej niewielki koszt oraz już posiadaną drukarkę 3D wykorzystującą właśnie tą technologię druku. 
Do druku drukarki wykorzystujące technologię FDM korzystają z tworzyw plastikowych takich jak ABS oraz PLA.
Filament, czyli materiał drukujący ("Tusz"), przechodzi przez głowicę drukarki, gdzie następuje jego podgrzanie aż do uzyskania formy płynnej materiału. 
Następnie jest on wyciskany przez dedykowaną dyszę (stosowane są różne średnice dysz) na stół roboczy. 
Dysza rozprowadza w przestrzeni roboczej filament w postaci nakładania na siebie kolejnych warstw, zgodnie z przygotowanym wcześniej projektem. 
Po nałożeniu warstwy następuje jej schłodzenie i filament twardnieje. 
Po naniesieniu ostatniej warstwy wydruku, wydruk (i elementy drugarki) musi się schłodzić, a następnie sam schodzi z powierzchni drukującej.

Zgodnie z \cite{prototyp3dzalety} „(...) prototypowanie z wykorzystaniem druku 3D pozwala na wypracowanie oszczędności – czasu i pieniędzy. Umożliwia szybkie testowanie prototypów i przyspiesza czas, jaki niezbędny jest do wprowadzenia docelowego produktu na rynek. Dodatkowo na każdym etapie procesu prototypowania można otrzymać natychmiast podgląd wydruku i śledzić proces powstawania modelu (...)”.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/ender3v2.jpg}
\caption{Drukarka 3D Creality Ender wykorzystana w projekcie \cite{img_me}. \label{ender3d}}
\quad
\end{figure}

\newpage
\subsection{Projekt obudowy}
W celu wykonania projektu obudowy zostały wykorzystane oprogramowanie SOLIDWORKS w wersji 20.
W początkowej fazie użyto oprogramowania Autodesk Fusion 360, jednak nie mogłem znaleźć w nim wielu narzędzi których się nauczyłem korzystać w SOLIDWORKS.

W ramach wykonania projektu ostatecznego były wprowadzane poprawki do projektu zgodnie z zasadą PDCA\footnote{P – PLAN (zaplanuj), D – DO (wykonaj), C – CHECK (sprawdź), A – ACT (popraw).} stanowiącą podstawę zwinnego projektowania.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/etui_bot_v1.jpg}
\caption{Podstawa obudowy. Wersja 1 \cite{img_me}. \label{etui_bot_v1}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/etui_bot_v7.1.jpg}
\caption{Podstawa obudowy. Wersja 7 \cite{img_me}. \label{etui_bot_v7.1}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/etui_bot_v9.1.jpg}
\caption{Podstawa obudowy. Wersja 9 \cite{img_me}. \label{etui_bot_v9.1}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/etui_bot_v10.2.jpg}
\caption{Podstawa obudowy. Wersja 10 \cite{img_me}. \label{etui_bot_v10.2}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/etui_top_v1.1.jpg}
\caption{Pokrywa obudowy. Wersja 1.1 \cite{img_me}. \label{etui_top_v1.1}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/etui_top_v1.5.jpg}
\caption{Pokrywa obudowy. Wersja 1.5 \cite{img_me}. \label{etui_top_v1.5}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/etui_top_v4.4.jpg}
\caption{Pokrywa obudowy. Wersja 4 \cite{img_me}. \label{etui_top_v4.4}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/zlozenie.jpg}
\caption{Rysunek złożeniowy kompletnej obudowy \cite{img_me}. \label{etui_zlozenie}}
\quad
\end{figure}

\newpage
\subsection{Wykonanie obudowy}
W celu osiągnięcia ostatecznego wyniku przeprowadzono kilka iteracji cyklu Deminga\footnote{Cykl Deminga – sposób strukturalnego wykonywania pracy w postaci 4 kroków (zaplanuj, wykonaj, sprawdź, popraw)} (PDCA) \cite{leanByJK}. W tym celu dokonywano także poprawek ustawień drukarki.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/print_0.jpg}
\caption{Iteracja Początkowa \cite{img_me}. \label{PDCA_00}}
\quad
\end{figure}

W pierwszej iteracji (Patrz rys. \ref{PDCA_00}) okazało się, że wymiary i rozmieszczenie bolców jest lekko przesunięte względem Raspberry Pi.

\newpage
W jednej z pośrednich iteracji (Patrz rys. \ref{PDCA_01}) okazało się, że otwory na panelach wyjścia / wejścia posiadają zbyt małą średnicę, oraz ekran nie był zamocowany stabilnie, ze względu na brak podpór.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/print_1.jpg}
\caption{Iteracja pośrednia 1 \cite{img_me}. \label{PDCA_01}}
\quad
\end{figure}

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/print_2.jpg}
\caption{Iteracja pośrednia 2 \cite{img_me}. \label{PDCA_02}}
\quad
\end{figure}

Następna iteracja (Patrz rys. \ref{PDCA_02}) miała na celu wydrukowanie poprawnych wymiarów dla kamery. Z powodu niewielkich rozmiarów urządzenia nie było łatwo dokładnie zmierzyć otworów. Nawet z uwzględnieniem niepewności pomiarowej trzeba było wydrukować komponent kilka razy z różnicą kilku dziesiątych mm.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/print_3.jpg}
\caption{Iteracja pośrednia 3 \cite{img_me}. \label{PDCA_03}}
\quad
\end{figure}

W jednej z końcowych iteracji (Patrz rys. \ref{PDCA_03}) celem było wpasowanie obu części obudowy w siebie nawzajem. Na "Papierze" wszystkie wymiary się zgadzały i powinny pasować. Jednak z względu niedoskonałości wydruku było inaczej.

\newpage
Ostatnia iteracja (Patrz rys. \ref{PDCA_END}) złożona z zamontowanymi w niej częściami, oraz śrubą aparatową pod stojak.
\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/print_last_assembled.jpg}
\caption{Iteracja końcowa \cite{img_me}. \label{PDCA_END}}
\quad
\end{figure}

Wszystkie wydrukowane Iteracje PDCA (Patrz rys. \ref{PDCA_ALL}).

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{imgs/print_all.jpg}
\caption{Wszystkie wydrukowane Iteracje \cite{img_me}. \label{PDCA_ALL}}
\quad
\end{figure}

\section{Realizacja projektu} \label{section:realizacja}
\subsection{Napotkane problemy}
W trakcie realizacji projektu napotkano następujące problemy.
\begin{itemize}
	\item \textbf{Wykorzystanie tylko jednego rdzenia procesora} (wątku). Raspberry Pi wyposażony jest w procesor czterordzeniowym, dzięki czemu można jednocześnie realizować 4 równoległe operacje. \newline \textbf{Problem:} \newline Okazało się że procesor Raspberry ma problemy z wykorzystaniem większej lioczby wątków w ramach jednego programu. \newline \textbf{Rozwiązanie:} \newline Użyto biblioteki threading do pracy na wątkach.
	\item \textbf{Brak możliwość realizacji komunikatów głosowych.} \newline \textbf{Problem:} \newline Pierwotnie zastosowany głośnik nie posiadał wsparcia dla realizacji komunikatów głosowych zapisanych w pamięci prototypu. Jedyną możliwością było odtwarzanie plików przez Spotify. \newline \textbf{Rozwiązanie:} \newline Zastosowano zewnętrzne głośniki podpinane przez złącze jack. Plusem tego rozwiązanie jest równiesz dowolność wyboru rozmiaru głośników.
	\item \textbf{Zbyt duża temperatura prototypu ze względu na konieczność wykonywania dużej liczby obliczeń.} \newline \textbf{Problem:} \newline W początkowej fazie projektu planowano użyć wyświetlacza zintegrowanego z głośnikiem. Okazało się iż takie rozwiązanie powoduje, że brakuje miejsca na radiator. \newline \textbf{Rozwiązanie:} \newline Znaleziono nowy wyświetlacz oraz wyprowadzono głośniki na zewnątrz przy pomocy gniazda typu jack.
\end{itemize}

\subsection{Możliwości rozbudowy}
W ramach projektu powstał pierwszy w pełni funkcjonalny prototyp inteligentnego rozpoznawania twarzy. Na etapie prototypu zostały zaimplementowane funkcjonalności, zgodnie z założeniami projektu.

Nie mniej sam system jest elastyczny i można go z czasem rozszerzyć o kolejne funkcjonalności:

\begin{itemize}
	\item integrację z istniejącymi na rynku systemami Smart Home,
	\item wprowadzenie funkcji nadzoru obszaru ze śledzeniem osób przemieszczających się w danych strefach,
	\item dodawanie zdjęć twarzy do bazy danych z wykorzystaniem kamery w którą wyposażony jest prototyp,
	\item zintegrowanie funkcji dostępu do pomieszczeń po rozpoznaniu twarzy, lub dzięki dotykowemu ekranowi, w który wyposażony jest projekt,
	\item generowanie sygnału uruchomiającego sekwencję zdarzeń po rozpoznaniu danej osoby. (na przykład włączenie czajnika lub ekspresu do kawy, czy też zapalenie światła w określonym pomieszczeniu),
	\item stworzenie centrali pobierającej dane z kilku - kilkunastu punktów zbudowanych na bazie obecnego prototypu.
\end{itemize}

\subsection{Koszty realizacji projektu}

\begin{center}
\begin{tabularx}{0.8\textwidth}{ 
|
>{\raggedright\arraybackslash}X 
|
>{\raggedleft\arraybackslash}X 
|
>{\raggedleft\arraybackslash}X
| 
}
\hline
\textbf{Element projektu} & \textbf{Cena [zł]} \\ \hline
Raspberry Pi 4b & 435.00 zł  \\ \hline
Kamera & 175.90 zł  \\ \hline
Ekran & 115.00 zł  \\ \hline
Głośnik & 49.99 zł  \\ \hline
Radiatory & 3,70 zł  \\ \hline
Obudowa & 50.00 zł  \\ \hline
Podstawka & 34.99 zł  \\ \hline
\textbf{Razem} & \textbf{865.58 zł}  \\ \hline
\end{tabularx}
\end{center}

Całkowity koszt projektu wyniósł 865.58 zł, co oznacza iż całość kosztów zawiera się w założonym budżecie.

\newpage
\section{Wnioski} \label{section:wnioski}
Stworzenie projektu inteligentnego rozpoznawania twarzy pozwala na sformułowanie kilku podstawowych wniosków, które powstały na bazie doświadczania przy realizacji zadania.

\begin{enumerate}
\item Wybrany temat pracy wymagał skutecznego połączenia wiedzy nabytej w trakcie studiów z zakresu elektroniki, programowania oraz projektowania z wykorzystaniem oprogramowania typu CAD.
\item Nawet przy ograniczonym budżecie możliwa jest realizacja zadań związanych z rozpoznawaniem twarzy i zbudowania prototypu, który w przyszłości będzie można integrować z rozwiązaniami typu Smart Home.
\item W trakcie realizacji projektu napotkano problemy, które należało rozwiązać. Okazało się, iż każdy problem może być rozwiązany przy zastosowaniu odpowiednich środków zaradczych.
\item Zastosowana technika druku 3D jest techniką zbyt wolną, aby produkować obudowy prototypów seryjnie. Nadaje się świetnie natomiast do prototypowania.
\item Zastosowane oprogramowanie nie może być na tym etapie użyte w zakresie ochrony dostępu, ponieważ nie zaimplementowano rozróżnienia żywej osoby od zdjęcia.
\end{enumerate}

\newpage

\bibliographystyle{plain}
\bibliography{praca_dyplomowa_krzysztof_kukiz}

\end{document}




